<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="lx.iseau.feature.controltower.ControlTowerDAO">

    <insert id="insertWatchEvent">
        INSERT INTO tb_watch (
        user_number,
        heart_rate,
        occurred_at,
        watch_location,
        watch_altitude
        )
        VALUES (
        #{userNumber, jdbcType=INTEGER},
        #{heartRate, jdbcType=INTEGER},
        CAST(#{occurredAt} AS TIMESTAMP with time zone),
        CASE
        <!-- ğŸš¨ ìˆ˜ì • ë¶€ë¶„: íŒŒë¼ë¯¸í„° ë’¤ì— ::numeric ë˜ëŠ” ::double precisionì„ ë¶™ì—¬ íƒ€ì…ì„ ëª…ì‹œ -->
        WHEN #{watchLatitude}::double precision IS NOT NULL
        AND #{watchLongitude}::double precision IS NOT NULL
        THEN ST_SetSRID(
        ST_MakePoint(
        #{watchLongitude, jdbcType=DOUBLE},
        #{watchLatitude, jdbcType=DOUBLE}
        ),
        4326
        )::geography
        ELSE NULL
        END,
        #{watchAltitude, jdbcType=DOUBLE}
        )
    </insert>
    
    <!-- ì¶”í›„ì— ì›Œì¹˜ ìµœì‹ ìˆœ ì¡°íšŒ
    <select id="selectLatestWatchByUser" parameterType="int" resultType="map">
       SELECT
           watch_nubmer,
           user_number,
           heart_rate,
           occurred_at,
           ST_Y(w.watch_location::geometry) AS latitude,
          ST_X(w.watch_location::geometry) AS longitude
       FROM tb_watch
       WHERE user_number = #{userNumber}
       ORDER BY occurred_at DESC
   </select>
    -->
   

    <insert id="insertTaskOnEmergency">
        INSERT INTO tb_task (manager_number, user_number, task_processed)
        VALUES (#{managerNumber}, #{userNumber}, 0)
    </insert>
    
    <insert id="insertTaskOnManualReport">
    INSERT INTO tb_task (
        manager_number,
        user_number,
        task_processed,
        type,
        task_location,
        occurred_at
    )
    VALUES (
        #{managerNumber},
        #{userNumber},
        0,
        #{reportType, jdbcType=VARCHAR},  CASE
            WHEN #{latitude} IS NOT NULL AND #{longitude} IS NOT NULL
            THEN ST_SetSRID(
                    ST_MakePoint(
                        #{longitude, jdbcType=DOUBLE},
                        #{latitude, jdbcType=DOUBLE}
                    ),
                    4326
                 )::geography
            ELSE NULL
        END,
        NOW()
    )
</insert>

   
    <!-- =========================
         ë§¤ë‹ˆì € ê¸°ë³¸ì •ë³´ ì¡°íšŒ
         ========================= -->
    <select id="selectManagerInfoByManagerNumber" resultType="ManagerInfoDTO">
        SELECT
            u.user_name AS managerName,
            u.mobile    AS mobile,
            u.email     AS email
        FROM tb_manager m
        JOIN tb_user u
          ON u.user_number = m.manager_number
        WHERE m.manager_number = #{managerNumber}
        LIMIT 1
    </select>

    <!-- =========================
         ë§¤ë‹ˆì € ê¸°ë³¸ì •ë³´ ìˆ˜ì •
         ========================= -->
    <update id="updateManagerInfoByManagerNumber" parameterType="ManagerInfoDTO">
        UPDATE tb_user u
           SET user_name = COALESCE(#{managerName}, u.user_name),
               mobile    = COALESCE(#{mobile}, u.mobile),
               email     = COALESCE(#{email}, u.email)
          FROM tb_manager m
         WHERE u.user_number = m.manager_number
            AND m.manager_number = #{managerNumber}
    </update>

    <!-- =========================
         ë§¤ë‹ˆì € ì²˜ë¦¬ ë¦¬ìŠ¤íŠ¸ (ê°„ë‹¨)
         - tb_task + tb_watch + tb_user(í”¼ì²˜) + tb_manager + tb_user(ë§¤ë‹ˆì €)
         ========================= -->
    <select id="getTaskListByManagerNumber"
           resultType="TaskListDTO">
     SELECT
       t.task_number    AS taskNumber,
       t.task_processed AS taskProcessed,
       w.occurred_at    AS occurredAt,
       u.birth_date     AS birthDate,
       u.gender         AS gender
     FROM tb_task t
     JOIN tb_watch   w ON w.user_number   = t.user_number
     JOIN tb_user    u ON u.user_number    = w.user_number
     JOIN tb_manager m ON m.manager_number = t.manager_number
     WHERE m.manager_number = #{managerNumber}
     ORDER BY w.occurred_at DESC
   </select>
     <!--  =========ìˆ˜ë™ì‹ ê³  í˜¸ì¶œëœê±° ì½ê¸°========= -->
   <select id="getTaskManualListByManagerNumber" resultType="TaskListDTO">
    SELECT
        t.task_number    AS taskNumber,
        t.task_processed AS taskProcessed,
        t.type           AS type,
        u.user_name      AS userName,  
        t.occurred_at    AS occurredAt,      
        
        u.birth_date     AS birthDate,       
        u.gender         AS gender,

        ST_X(t.task_location::geometry) AS userLon,
        ST_Y(t.task_location::geometry) AS userLat

    FROM tb_task t
    JOIN tb_user u ON u.user_number = t.user_number
    JOIN tb_manager m ON m.manager_number = t.manager_number
    
    WHERE m.manager_number = #{managerNumber}
      AND t.type IN ('MISSING', 'DROWNING', 'COLLAPSE', 'INJURY', 'MANUAL')
    
    ORDER BY t.occurred_at DESC
</select>

   

    <!-- =========================
         ì²˜ë¦¬ ìƒì„¸ (taskNumber)
         ========================= -->
         <select id="getTaskDetailByTaskNumber"
        parameterType="int"
        resultType="TaskDetailDTO">
    SELECT
        t.task_number AS taskNumber,
        t.task_processed AS taskProcessed,
        t.type AS type,
        
        -- ğŸš¨ [ìˆ˜ì • 1] ìœ„ì¹˜ í†µí•©: Task > Watch > User ìˆœìœ¼ë¡œ 3ê°€ì§€ ìœ„ì¹˜ë¥¼ COALESCE
        COALESCE(
            ST_X(t.task_location::geometry), 
            ST_X(w_latest.watch_location::geometry), 
            ST_X(u.location::geometry)
        ) AS userLon,
        COALESCE(
            ST_Y(t.task_location::geometry), 
            ST_Y(w_latest.watch_location::geometry), 
            ST_Y(u.location::geometry)
        ) AS userLat,
        
        u.birth_date AS birthDate,
        u.gender AS gender,
        
        -- ğŸš¨ [ìˆ˜ì • 2] ì‹œê°„ í†µí•©: Task ë°œìƒ ì‹œê°ì„ ìµœìš°ì„ ìœ¼ë¡œ ì‚¬ìš©
        COALESCE(t.occurred_at, w_latest.occurred_at) AS occurredAt,
        
        w_latest.heart_rate AS heartRate
        
    FROM tb_task t
    JOIN tb_user  u ON u.user_number  = t.user_number
    
    -- Watch ë°ì´í„° (BPM/ìœ„ì¹˜)ë¥¼ ìµœì‹  1ê±´ë§Œ ê°€ì ¸ì˜¤ëŠ” LEFT JOIN
    LEFT JOIN (
        SELECT user_number, occurred_at, heart_rate, watch_location
        FROM tb_watch w_sub
        WHERE w_sub.occurred_at = (SELECT MAX(occurred_at) FROM tb_watch WHERE user_number = w_sub.user_number)
    ) w_latest ON w_latest.user_number = t.user_number 
    
    WHERE t.task_number = #{taskNumber}
    LIMIT 1
</select>

  <!-- =========================(ì§€ì„œ)
         ë¡œê·¸ ë°ì´í„° ì¡°íšŒ (userNumber)
         - tb_watch
         ========================= -->
    <select id="getTaskLogByUserNumber"
          resultType="TaskLogDTO"
          parameterType="int">

      SELECT
          w.occurred_at AS forTime,
          w.heart_rate  AS hr
      FROM tb_task t
      JOIN tb_watch w
        ON w.user_number = t.user_number
      WHERE t.user_number = #{userNumber}
      ORDER BY w.occurred_at DESC;

   </select>


  <!-- =========================(ì§€ì„œ)
         ê´€ì œì„¼í„° ì²˜ë¦¬ ë¦¬ìŠ¤íŠ¸ (í•©ì¹˜ê¸°)
         - tb_task + tb_watch + tb_user(í”¼ì²˜) + tb_manager + tb_user(ë§¤ë‹ˆì €) + tb_control_tower
         ========================= -->
   <select id="getTaskListByControlTowerNumber"
        resultType="ControlTowerTaskListDTO"
        parameterType="int">

    SELECT *
    FROM (
      SELECT
        t.task_number    AS id,
        t.user_number    AS userNumber,
        t.task_processed AS taskProcessed,
        t.type           AS type,
        u.birth_date     AS birthDateForAge,
        u.gender         AS gender,
        
        -- ì‹œê°„/ìœ„ì¹˜ í†µí•© ë¡œì§ (COALESCE ì‚¬ìš©)
        COALESCE(t.occurred_at, w.occurred_at) AS dateAndTime, 
        ST_X(u.location::geometry) AS userLon,
        ST_Y(u.location::geometry) AS userLat,
        ST_X(w.watch_location::geometry) AS watchLon,
        ST_Y(w.watch_location::geometry) AS watchLat,
        w.heart_rate     AS hr,
        w.watch_count    AS count,
        m.manager_number AS managerNumber,
        b.beach_name     AS beachName,
        
        -- ğŸš¨ [í•µì‹¬ ìˆ˜ì •] Taskë¥¼ user_number ê¸°ì¤€ìœ¼ë¡œ ìµœì‹  1ê±´ë§Œ ê°€ì ¸ì˜¤ê¸° ìœ„í•œ RN
        ROW_NUMBER() OVER (
          PARTITION BY t.user_number 
          ORDER BY COALESCE(t.occurred_at, w.occurred_at) DESC
        ) AS rn 
        
      FROM tb_task t
      JOIN tb_manager m ON m.manager_number = t.manager_number
      JOIN tb_control_tower c ON c.control_tower_number = m.control_tower_number
      JOIN tb_user u ON u.user_number = t.user_number
      LEFT JOIN tb_beach b ON b.beach_number = u.beach_number
      
      -- Watch ê¸°ë¡ì´ ì—†ì–´ë„ Taskê°€ ë³´ì´ë„ë¡ LEFT JOIN (ìµœì‹  1ê±´)
      LEFT JOIN (
        SELECT user_number, occurred_at, heart_rate, watch_location, COUNT(*) OVER (PARTITION BY user_number) AS watch_count,
               ROW_NUMBER() OVER (PARTITION BY user_number ORDER BY occurred_at DESC) AS rn_watch
        FROM tb_watch
      ) w ON w.user_number = t.user_number AND w.rn_watch = 1 
      
      WHERE c.control_tower_number = #{controlTowerNumber}
    ) sub
    -- ğŸš¨ [í•„í„°ë§ ì¶”ê°€] rn=1ì¸ Taskë§Œ ë‚¨ê²¨ì„œ ì‚¬ìš©ìë‹¹ ìµœì‹  Task 1ê±´ë§Œ í‘œì‹œ
    WHERE sub.rn = 1 
    ORDER BY sub.dateAndTime DESC;

</select>
    <!-- =========================
         ì²˜ë¦¬ì™„ë£Œ í”Œë˜ê·¸ ìˆ˜ì •
         ========================= -->
    <update id="updateTaskProcessed">
        UPDATE tb_task
           SET task_processed = #{taskProcessed}
         WHERE task_number    = #{taskNumber}
    </update>

</mapper>
