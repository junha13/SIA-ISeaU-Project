<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="lx.iseau.feature.beach.BeachDAO">

   <select id="findBeacheList" parameterType="BeachListRequest" resultType="BeachVO">
    SELECT
        beach_number,
        beach_name,
        beach_image,
        beach_information,
        rating,
        approved_by_ministry,
        address,    
        ST_Y(LOCATION::geometry) AS latitude,         
        ST_X(LOCATION::geometry) AS longitude,
        mobile,
        open_date,
        close_date
        FROM
        tb_beach
    WHERE
        1=1
   
    <if test="region != null and region != ''">
        AND address LIKE CONCAT(#{region}, '%')
    </if>
    
    <choose>
        <when test="sort == 'rating_desc'">
            ORDER BY rating DESC, beach_name ASC
        </when>
        <when test="sort == 'name_asc'">
            ORDER BY beach_name ASC
        </when>
        <otherwise>
            ORDER BY beach_number ASC
        </otherwise>
    </choose>
</select>

	<select id="getBeachDetailInfo" parameterType="int" resultType="ResponseBeachDTO">
		select beach_number,
		        beach_name,
		        beach_image,
		        beach_information,
		        rating,
		        approved_by_ministry,
		        address,    
		        ST_Y(LOCATION::geometry) AS latitude,         
		        ST_X(LOCATION::geometry) AS longitude,
		        mobile,
		        open_date,
		        close_date
		from tb_beach
		where beach_number = #{beachNumber}
	</select>
<select id="getBeachDetailDanger" parameterType="int" resultType="ResponseBeachDangerDTO">
<![CDATA[
WITH beach_location AS (
    SELECT location 
    FROM tb_beach 
    WHERE beach_number = #{beachNumber}
)
SELECT
    w.wave_height AS waveHeight,
    w.sea_surface_temperature AS seaSurfaceTemperature,
    w.forecast_time AS forecastTime,
    ST_Y(w.observed_location::geometry) AS latitude,
    ST_X(w.observed_location::geometry) AS longitude
FROM
    tb_beach_weather_info w,
    beach_location b
WHERE
    ST_DWithin(w.observed_location, b.location, 10000)
    AND w.forecast_time >= DATE_TRUNC('day', NOW())
    AND w.forecast_time < DATE_TRUNC('day', NOW()) + INTERVAL '1 day'
ORDER BY
    w.forecast_time ASC
]]>
</select>
<select id="getBeachDetailWeather" parameterType="int" resultType="ResponseBeachWeatherDTO">
    WITH beach_location AS (
        SELECT location FROM tb_beach WHERE beach_number = #{beachNumber}
    )
    
    SELECT
        -- 1. tb_weather_info
        w.temperature,
        w.humidity,
        w.rain,
        w.wind_gusts,
        w.wind_speed,
        w.wind_direction,
        w.forecast_time,

        -- 2. tb_uv_info (LEFT JOIN 되므로 데이터가 없으면 NULL)
        u.rain_probability,
        u.uv_index,
        u.uv_index_clear_sky

    FROM
        tb_weather_info w
    
    -- [수정] 해변 위치(b)를 먼저 JOIN
    JOIN
        beach_location b 
        -- 날씨(w)가 10km 반경 내에 있어야 함 (메인 조건)
        ON ST_DWithin(w.observed_location, b.location, 10000)

    -- [수정] UV(u) 정보는 LEFT JOIN으로 변경
    LEFT JOIN
        tb_uv_info u
        -- 조건 1: 날씨(w)와 예보 시간이 같아야 함
        ON w.forecast_time = u.forecast_time
        -- 조건 2: UV(u) 데이터도 10km 반경 내에 있어야 함
        AND ST_DWithin(u.observed_location, b.location, 10000)

    WHERE
        -- [수정] 메인 테이블(w)의 시간 조건
        w.forecast_time >= NOW()
        
    ORDER BY
        -- 5. 해변 위치와 (날씨 데이터를 기준으로) 가장 가까운 순서, 그다음 시간 순으로 정렬
        ST_Distance(w.observed_location, b.location) ASC, 
        w.forecast_time ASC
        
    LIMIT 72;
</select>
	
<!-- BeachDAO.xml 파일 내부 -->
<select id="getBeachFavorites" parameterType="int" resultType="ResponseFavoritesDTO">
    SELECT
        b.beach_number AS beachNumber,
        b.beach_name AS beachName,
        b.beach_image AS beachImage,
        b.beach_information AS beachInformation,
        b.rating AS rating,
        b.approved_by_ministry AS approvedByMinistry,
        b.address AS address,    
        ST_Y(b.LOCATION::geometry) AS latitude,         
        ST_X(b.LOCATION::geometry) AS longitude,
        b.mobile AS mobile,
        b.open_date AS openDate,
        b.close_date AS closeDate
    FROM
        tb_beach_saved bs
    JOIN
        tb_beach b ON bs.beach_number = b.beach_number
    WHERE
        bs.user_number = #{userNumber}
    ORDER BY
        b.beach_name ASC
</select>
    <insert id="insertFavorite" parameterType="BeachFavoritesVO">
        INSERT INTO tb_beach_saved (user_number, beach_number)
        VALUES (#{userNumber}, #{beachNumber})
    </insert>

    <delete id="removeFavorite" parameterType="BeachFavoritesVO">
        DELETE FROM tb_beach_saved
        WHERE user_number = #{userNumber}
          AND beach_number = #{beachNumber}
    </delete>

    <select id="findFavoriteBeachByUser" parameterType="int" resultType="int">
        SELECT beach_number
        FROM tb_beach_saved
        WHERE user_number = #{userNumber}
    </select>

    <select id="checkFavoriteExists" parameterType="BeachFavoritesVO" resultType="int">
        SELECT COUNT(*)
        FROM tb_beach_saved
        WHERE user_number = #{userNumber}
          AND beach_number = #{beachNumber}
    </select>
    
    
</mapper>
