<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="lx.iseau.feature.beach.BeachDAO">

  <select id="findBeacheList" parameterType="BeachListRequest" resultType="BeachVO">
    SELECT
        b.beach_number,
        b.beach_name,
        b.beach_image,
        b.beach_information,
        b.rating,
        b.approved_by_ministry,
        b.address,
        ST_Y(ST_Transform(b.location::geometry, 4326)) AS latitude,
        ST_X(ST_Transform(b.location::geometry, 4326)) AS longitude,
        b.mobile,
        b.open_date,
        b.close_date,
        COALESCE(c.review_count, 0) AS review_count,
        
        -- ✅ [핵심 수정] 태그를 쉼표로 연결하여 하나의 문자열로 조회
        STRING_AGG(t_name.tag_name, ',') AS tags_string
        
        <if test="sort == 'distance_asc' and userLatitude != null and userLongitude != null">
        , ST_Distance(
            b.location,
            ST_SetSRID(ST_MakePoint(#{userLongitude}, #{userLatitude}), 4326)::geography
        ) AS distance_meters
        </if>
    FROM tb_beach b
    
    -- 태그 목록 조회를 위한 LEFT JOIN
    LEFT JOIN tb_beach_tag_list t_list ON t_list.beach_number = b.beach_number
    LEFT JOIN tb_beach_tag t_name ON t_name.tag_number = t_list.tag_number
    
    LEFT JOIN (
        SELECT beach_number, COUNT(*) AS review_count
        FROM tb_beach_comment_list
        GROUP BY beach_number
    ) c ON c.beach_number = b.beach_number
    
    WHERE 1=1

    <if test="region != null and region != ''">
      AND b.address LIKE CONCAT(#{region}, '%')
    </if>

    <if test="category != null and category != ''">
      AND b.category = #{category}
    </if>
    
    <if test="tagFilter != null and tagFilter != ''">
      AND t_name.tag_name = #{tagFilter}
    </if>
    
    GROUP BY
        b.beach_number, b.beach_name, b.beach_image, b.beach_information, b.rating,
        b.approved_by_ministry, b.address, b.location, b.mobile, b.open_date, b.close_date,
        c.review_count
        <if test="sort == 'distance_asc' and userLatitude != null and userLongitude != null">
        , distance_meters
        </if>
        
    <choose>
<when test="sort == 'distance_asc' and userLatitude != null and userLongitude != null">
        ORDER BY distance_meters ASC, b.beach_name ASC
      </when>
      <when test="sort == 'review_desc'">
        ORDER BY COALESCE(c.review_count, 0) DESC,
                 b.rating DESC,
                 b.beach_name ASC
      </when>
      <when test="sort == 'rating_desc'">
        ORDER BY b.rating DESC NULLS LAST, b.beach_name ASC
      </when>
      <when test="sort == 'name_asc'">
        ORDER BY b.beach_name ASC
      </when>
      <otherwise>
        ORDER BY b.beach_number ASC
      </otherwise>
    </choose>
    </select>
  <select id="getBeachDetailInfo" parameterType="int" resultType="ResponseBeachDTO">
    <![CDATA[
    SELECT beach_number,
           beach_name,
           beach_image,
           beach_information,
           rating,
           approved_by_ministry,
           address,
           ST_Y(location::geometry) AS latitude,
           ST_X(location::geometry) AS longitude,
           mobile,
           open_date,
           close_date
    FROM tb_beach
    WHERE beach_number = #{beachNumber}
    ]]>
  </select>


  <select id="getBeachDetailDanger" parameterType="int" resultType="ResponseBeachDangerDTO">
    <![CDATA[
    WITH beach_location AS (
        SELECT location
        FROM tb_beach
        WHERE beach_number = #{beachNumber}
    )
    SELECT
        w.wave_height AS waveHeight,
        w.sea_surface_temperature AS seaSurfaceTemperature,
        w.forecast_time AS forecastTime,
        ST_Y(w.observed_location::geometry) AS latitude,
        ST_X(w.observed_location::geometry) AS longitude
    FROM tb_beach_weather_info w,
         beach_location b
    WHERE ST_DWithin(w.observed_location, b.location, 20000)
      AND w.forecast_time >= DATE_TRUNC('day', NOW())
      AND w.forecast_time < DATE_TRUNC('day', NOW()) + INTERVAL '1 day'
    ORDER BY w.forecast_time ASC
    ]]>
  </select>


  <select id="getBeachDetailWeather" parameterType="int" resultType="ResponseBeachWeatherDTO">
    <![CDATA[
    WITH beach_location AS (
        SELECT location FROM tb_beach WHERE beach_number = #{beachNumber}
    )
    SELECT
        w.temperature,
        w.humidity,
        w.rain,
        w.wind_gusts,
        w.wind_speed,
        w.wind_direction,
        w.forecast_time,
        u.rain_probability,
        u.uv_index,
        u.uv_index_clear_sky
    FROM tb_weather_info w
    JOIN beach_location b
      ON ST_DWithin(w.observed_location, b.location, 10000)
    LEFT JOIN tb_uv_info u
      ON w.forecast_time = u.forecast_time
     AND ST_DWithin(u.observed_location, b.location, 10000)
    WHERE w.forecast_time >= NOW()
    ORDER BY ST_Distance(w.observed_location, b.location) ASC,
             w.forecast_time ASC
    LIMIT 72
    ]]>
  </select>


  <select id="getBeachFavorites" parameterType="int" resultType="ResponseFavoritesDTO">
    <![CDATA[
    SELECT
        b.beach_number AS beachNumber,
        b.beach_name AS beachName,
        b.beach_image AS beachImage,
        b.beach_information AS beachInformation,
        b.rating AS rating,
        b.approved_by_ministry AS approvedByMinistry,
        b.address AS address,
        ST_Y(b.location::geometry) AS latitude,
        ST_X(b.location::geometry) AS longitude,
        b.mobile AS mobile,
        b.open_date AS openDate,
        b.close_date AS closeDate
    FROM tb_beach_saved bs
    JOIN tb_beach b ON bs.beach_number = b.beach_number
    WHERE bs.user_number = #{userNumber}
    ORDER BY b.beach_name ASC
    ]]>
  </select>


  <insert id="insertFavorite" parameterType="BeachFavoritesVO">
    <![CDATA[
    INSERT INTO tb_beach_saved (user_number, beach_number)
    VALUES (#{userNumber}, #{beachNumber})
    ]]>
  </insert>

  <delete id="removeFavorite" parameterType="BeachFavoritesVO">
    <![CDATA[
    DELETE FROM tb_beach_saved
    WHERE user_number = #{userNumber}
      AND beach_number = #{beachNumber}
    ]]>
  </delete>


  <select id="getBeachComments" parameterType="int" resultType="ResponseBeachCommentDTO">
    <![CDATA[
    SELECT c.beach_comment_number AS beachCommentNumber,
           c.comment_content      AS commentContent,
           c.created_time         AS createdTime,
           c.rating               AS rating,
           c.beach_number         AS beachNumber,
           c.user_number          AS userNumber,
           u.id            AS userId
    FROM tb_beach_comment_list c
    JOIN tb_user u ON u.user_number = c.user_number
    WHERE c.beach_number = #{beachNumber}
    ORDER BY c.created_time DESC, c.beach_comment_number DESC
    ]]>
  </select>

  <insert id="insertBeachComment" parameterType="ResponseBeachCommentDTO" useGeneratedKeys="true" keyProperty="beachCommentNumber">
    <![CDATA[
    INSERT INTO tb_beach_comment_list
    (comment_content, created_time, rating, beach_number, user_number)
    VALUES
    (#{commentContent}, COALESCE(#{createdTime}, NOW()), #{rating}, #{beachNumber}, #{userNumber})
    ]]>
  </insert>

  <update id="updateBeachComment" parameterType="ResponseBeachCommentDTO">
    <![CDATA[
    UPDATE tb_beach_comment_list
    SET comment_content = #{commentContent},
        rating          = #{rating}
    WHERE beach_comment_number = #{beachCommentNumber}
      AND user_number = #{userNumber}
    ]]>
  </update>

  <delete id="deleteBeachComment" parameterType="ResponseBeachCommentDTO">
    <![CDATA[
    DELETE FROM tb_beach_comment_list
    WHERE beach_comment_number = #{beachCommentNumber}
      AND user_number = #{userNumber}
    ]]>
  </delete>
  
	 <select id="getMyBeachComments" resultType="ResponseBeachCommentDTO">
	  <![CDATA[
	  SELECT
	    c.beach_comment_number AS beachCommentNumber,
	    c.comment_content      AS commentContent,
	    c.created_time         AS createdTime,
	    c.rating               AS rating,
	    c.beach_number         AS beachNumber,
	    c.user_number          AS userNumber,
	    u.id                   AS userId
	  FROM tb_beach_comment_list c
	  JOIN tb_user u ON u.user_number = c.user_number
	  WHERE c.user_number = #{userNumber}
	  ]]>
	  <choose>
	    <when test="sort == 'oldest'">
	      ORDER BY c.created_time ASC, c.beach_comment_number ASC
	    </when>
	    <otherwise>
	      ORDER BY c.created_time DESC, c.beach_comment_number DESC
	    </otherwise>
	  </choose>
	</select>
  

</mapper>